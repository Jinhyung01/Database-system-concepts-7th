# Chapter 01 서론

#### **DBMS(database - management - system, 데이터 베이스 관리,운영하는 시스템)**

서로 관계있는 데이터들의 모임과 그 데이터에 접근하기 위한 프로그램 집합으로 구성된다.

- 목적
  1. 데이터베이스에 정보를 저장하고
  2. 이를 검색하기 위한 편리하고 효율적인 환경을 제공하는 것

<br/>

#### **database : 데이터들의 집합(단순한 집합이 아니라 일반적으로 잘 정리되어 표준화된 집합)**

- 대규모의 정보를 **관리**하도록 설계된다.
  - **관리** = 정보 저장구조를 정의하는 작업 + 저장된 정보를 조작하기 위한 기법

<br/>

#### **DBS(database system)**

DB와 DBMS를 이용하여 조직에 필요한 정보를 제공해주는 시스템

데이터베이스를 생성,사용,저장,관리하는 시스템 전체를 의미하며(DB+ DBMS + DB application을 포괄하는 개념)

1. **저장된 정보를** 시스템 고장이나 모든 불법적인 접근 등으로부터 **안전하게 보호해야 한다**.
2. 데이터가 여러 사용자 간에 공유될 경우 생길 수 있는 예기치 않은 이상 결과를 방지해야한다.
3. 대규모의 복잡한 데이터에 대해서 더 단순하고 **추상화된 관점을 제공**한다.

<br/>

## 1.1 데이터베이스 시스템의 응용(Database-System Application)

오늘날 모든 기업은 가상적으로 모든 고객이 기업의 데이터베이스, 즉 기업 자체와 직접적으로 소통할 수 있도록 도와주는 웹 application을 사용하고 있다.

#### **abstraction(추상화)** 

- 사람이 장치나 시스템이 어떻게 구성되었는지에 대한 자세한 사항을 알 필요 없이 복잡한 장치나 시스템을 사용할 수 있도록함

<br/>

데이터베이스는 두 가지 모드로 사용된다.

**1. online transaction processing(온라인 트랜잭션 처리)**을 지원하는 모드

- **대규모 사용자들이 데이터베이스를 사용하며 각 사용자는 비교적 적은 양의 데이터에 대한 검색이나 갱신을 주로한다.**
- 대부분의 데이터베이스 응용을 위한 **primary mode**이다.

**2. data analysis(데이터 분석)**을 지원하는 모드

- 비지니스 결정을 내리기 위해 결론을 끌어내고 규칙을 추론하거나
- **어떤 결정을 내리기 위해 데이터를 분석하는 것**

<br/>

## 1.2 데이터베이스 시스템의 목적

DBMS가 등장하기 전까지는 **파일 처리 시스템(file-processing system)**에 정보를 저장했다.



![파일처리시스템](https://github.com/user-attachments/assets/e115262e-4b8a-4915-a096-58c3a815f394)

- 데이터를 파일 단위로 관리하고 응용 프로그램이 독립적으로 파일에 접근하여 데이터를 저장 및 처리하는 시스템

- 각 파일은 특정한 작업이나 응용 프로그램에 맞춰 관리된다.
- 데이터는 분산된 상태로 유지된다.
- 파일과 응용 프로그램 간의 높은 의존성이 특징이다

<br/>

#### **단점**

**<span style="color:blue">데이터의 중복과 비일관성</span>**

- **파일과 응용 프로그램은** 장기간에 걸쳐 서로 다른 많은 프로그래머에 의해 개발되므로 **파일이 서로 다른 형식을 갖기 싶고, 응용 프로그램이 서로 다른 언어로 작성될 수도 있다.** 게다가 **동일한 정보가 여러 파일에 중복 저장될 것이다.**
- 이러한 중복은 다음과 같은 문제를 낳는다.
  - 저장 공간의 낭비
  - 접근 비용 증가
  - 데이터의 비일관성(data inconsistency) : 동일한 데이터의 여러 사본이 서로 다른 값을 보유하고 있는 상태를 말한다.

<br/>

**<span style="color:blue">데이터 접근의 어려움</span>**

- 파일 처리 시스템 환경에서는 **필요한 데이터를 편리하고 효율적으로 검색하기가 힘들다.** 

<br/>

**<span style="color:blue">데이터 고립</span>**

- 데이터가 여러 파일에 흩어져 있고 파일 형식이 서로 다르기 때문에 원하는 **데이터를 검색하는 프로그램을 새로 작성하기 어렵다**.

<br/>

**<span style="color:blue">무결성(integrity)문제</span>**

**무결성** : DB에서 데이터의 정확성, 일관성을 유지하는것(즉, 데이터 결함이 없는 상태)

- 정확성 : 데이터가 올바르게 입력되고, 반영되어야 한다.

- 일관성 : 데이터가 여러 위치나 테이블에서 동일하게 유지되어야 한다. 한 테이블에서 고객의 주소가 변경되면, 다른 관련 테이블에서도 같은 주소가 반영되어야 한다.

**무결성 제약조건(Integrity constraint)** : DB상태가 만족시켜야하는 조건이자 사용자에 의한 DB갱신이 DB의 일관성을 깨지 않도록 보장하는 수단.

- 파일 처리 시스템은 새로운 제약 조건이 추가될때 기존 프로그램을 일일이 변경하여 해당 제약 조건을 새롭게 만족한다는 것은 쉬운 일이 아니다.
- **새로운 제약조건이** 단일 파일이 아니라 **여러 파일에 적용되거나**, **여러 종류의 데이터 항목에 걸쳐 적용되어야 하면**, 이를 맞추기 위해 **많은 작업과 조정이 필요**하다.

<br/>

**<span style="color:blue">원자성 문제</span>**

**원자성(atomic)** : 일련의 과정 전체가 수행되든지 아니면 어느 것도 수행되지 않아야 한다.

- 기존 파일 처리 시스템에서는 원자성을 보장하기 어렵다. 

<br/>

**<span style="color:blue">동시 접근의 문제</span>**

- 시스템의 전반적인 성능을 향상하고 응답 시간을 단축하기 위해, 많은 시스템은 여러 사용자가 데이터를 동시에 갱신할 수 있도록한다. 이런 상황에서는 **동일한 데이터가 여러 사용자에 의해 동시에 갱신될 수 있는데, 이는 데이터의 비일관성을 야기할 수 있다.**
  - 파일 처리 시스템에서는 **데이터가** 사전에 조정되지 않은 **수많은 응용프로그램에 의해 접근되므로 이를 관리하기 어렵다.**

<br/>

**<span style="color:blue">보안 문제</span>**

- DBS의 모든 사용자가 모든 데이터에 접근하는 것은 아니다.(ex : 대학교 급여 담당 직원은 재무 정보가 들어있는 DB부분 만 보면됨)
- 파일 처리 시스템에서는 응용 프로그램이 그때그때 바로 추가되므로 보안 규칙을 일일이 적용하는 게 어렵다

<br/>

## 1.3 데이터의 관점

DBS는 서로 관련이 있는 파일의 모임이자 사용자로 하여금 이 파일에 접근하도록 하거나 수정하도록 하는 프로그램의 집합

DBS의 주요 목적

- 사용자에게 데이터에 관한 추상적인 관점을 제공하는것(즉, 시스템은 데이터가 어떻게 저장되고 유지되는지에 관한 세부 사항은 사용자로 부터 은폐한다.)

<br/>

### 1.3.1 데이터 모델

DB구조의 기반이 되는 것이 데이터 모델(data model)로서, 이는 **데이터, 데이터들 사이의 관계, 데이터의 의미, 그리고 일관성 제약조건등을 기술하기 위한 개념적 표현의 집합**이다.

<br/>

#### 데이터 모델은 크게 4개로 분류된다.

- **관계형 모델(Relational Model)** 

  - 관계형 모델은 데이터와 이들 데이터 사이의 관계를 나타내기 위해 테이블의 모임을 사용한다.

  - 레코드 기반 모델 이다.

    > DB가 몇 개의 type으로 이루어진 고정 형식의 레코드로 구성되기 때문에 

- **개체-관계 모델(Entity - Relationship Model)**

  - 기본적인 객체들의 집합인 **개체(entity)**와 이러한 개체들 간의 **관계(relationship)**를 사용한다.

- **반구조형 데이터 모델(Semi - structured Data Model)**

  - 같은 형식을 갖고 있으나 다소 다른 속성을 가진 개별적 데이터 항목을 기술하기 위한 **비정형 데이터 모델**이다.

    > 비정형 데이터 모델 : 이 모델은 정해진 스키마가 없이 유연하게 다양한 형식의 데이터를 저장할 수 있는 DB를 의미

  - JSON과 확장성 마크업 언어(extensible markup language)인 XML이 반구조형 데이터를 표현하는데 널리 사용됨

- **객체 기반 데이터 모델(Object-Based Data Model)**

  - 객체 개념이 관계형 DB에 잘 통합되어있는 모델
  - 객체지향 데이터 모델을 구성하는 **기본 요소인 객체**는 해당 객체의 상태를 나타내는 **속성이나 메소드로 구성된다**
  

<br/>

### 1.3.2 관계형 데이터 모델

관계형 모델에서 **데이터는 테이블로 표현된다**. 

각 테이블은 다수의 열을 가지고 있으며 각 열은 유일한 이름을 갖는다.

테이블의 각 행은 정보의 한 조각을 표현한다.

![그림 1 1 관계형 DB의 예](https://github.com/user-attachments/assets/13d8e5d0-1d06-4888-a8fb-df763b2758b9)

<br/>

### 1.3.3 데이터 추상화

많은 DBS의 경우 사용자 대부분이 컴퓨터를 잘 다루지 못하는 일반인이므로, 여러 단계의 **데이터 추상화(data abstraction)**을 통해 이러한 복잡한 구조를 되도록이면 감추어 사용자의 이해와 편의를 도와야한다.

![그림 1 2 데이터 추상화의 세 단계](https://github.com/user-attachments/assets/43ccc77e-3512-47f2-8e9e-f3ea131d9c2b)

#### **데이터 추상화의 세 가지 단계**

- 물리적 단계(Physical level)

  - 추상화의 최하위 단계
  - **데이터가 실제로 어떻게 저장되는지 기술한다.**
  - 복잡한 하위 단계의 데이터 구조가 상세히 기술된다.
  - 데이터베이스 시스템은 낮은 단계의 상세한 저장 구조를 DB 프로그래머에게 숨긴다.(DBA는 알고 있을 수 도 있다)
  - 물리적 단계에서 레코드는 연속된 기억 장소에 위치한 하나의 블록 단위로 기술될 수 있다.


<br/>

- 논리적 단계(Logical level)

  - **어떤 데이터가 저장되었는지 그리고 데이터들 사이에는 어떤 관계가 있는지를 기술한다.**

  - 전체 DB를 몇 개의 비교적 간단한 데이터 구조를 이용하여 기술한다.

  - 각 레코드는 아래 코드처럼 타입 정의에 의해 기술되며, 레코드들 사이의 관계도 이 단계에서 잘 정의되어 있어야 한다.

    - instructor 레코드의 dept_name 값이 반드시 department 테이블에 나와야 한다는 요구사항이 이러한 레코드들 관의 관계라고 할 수 있다.

    ```
    type instructor = record
    					ID : char(5);
    					name : char(20);
    					dept_name : char(20);
    					salary : numeric(8,2);
    				  end;
    				  
    네 개의 field를 가지는 instructor라는 새로운 레코드를 정의하고 있다. 각 필드는 고유한 이름과 그에 적당한 타입을 가진다.
    - char(2)은 20개의 문자로 구성될 수 있는 문자열을 의미
    - numeric(8,2)은 소수점 이하 2자리를 포함 총 8자리 숫자로 구성된 수를 의미
    ```

  -  **물리적 데이터 독립성(physical data independence)**

    - 간단한 구조를 구현하기 위해서는 복잡한 물리적 단계의 구조를 알아야 하는 것이 사실이나, 논리적 단계의 user는 이러한 복잡한 구조에 대해 전혀 알 필요가 없다. 


    - 어떤 정보가 DB에 저장되어야 할지를 결정하는 DBA(database administrator)가 이 단계에서 작업함
      - 프로그래밍 언어를 사용하는 프로그래머 역시 이 단계에서 작업한다.


<br/>


- 뷰 단계(View level)
  - 추상화의 최상위 단계. 
  - 컴퓨터 사용자는 데이터 타입의 상세한 부분을 숨기고 있는 응용 프로그램을 사용한다.
  - 전체 DB의 일부분만을 기술한다.
    - 사용자는 DB의 모든 데이터에 관심이 있는 것이 아니라 극히 일부분에만 관심이 있다.
  - 논리적 단계의 상세함을 숨기는 것과 동시에 뷰는 사용자가 데이터베이스의 특정 부분에 접근하지 못하도록 하는 보안 메커니즘도 제공
  - 사용자가 시스템을 간단히 이용할 수 있도록 정의된다.
  - 한 DB에 대해서 수많은 view 가 존재할 수 있다.

<br/>

관계형 모델과 같은 데이터 모델의 중요한 특징은 단순한 DB사용자뿐만 아니라 DB Application 개발자에게 이러한 낮은 단계의 구현 사항을 숨기는 것이다. **DBS는 개발자가 데이터 모델의 추상화를 이용해 데이터를 저장하고 검색하는 것을 허용하고 추상화 연산을 낮은 단계 구현물의 연산으로 변환한다.**

<br/>

### 1.3.4 인스턴스와 스키마

DB는 정보가 추가되고 삭제됨에 따라 시시각각 변한다.

**인스턴스(instance)** : 어느 특정한 순간에 DB에 저장되어 있는 정보의 모임

**스키마(schema)** : DB의 전체적인 설계를 이야기할 때 데이터베이스 스키마라고 한다.

<br/>

#### 데이터베이스 시스템에는 추상화의 단계에 따라 여러 개의 스키마가 존재한다.

- **물리적 스키마(physical schema)** : 물리적 단계에서 데이터베이스 설계를 기술

- **논리적 스키마(logical schema)** : 논리적 단계에서 데이터베이스 설계를 기술

  > 대부분의 응용 프로그램이 논리적 스키마에 기반하여 작성되기 때문에 응용 프로그램에 가장 큰 영향을 미친다.

- **서브 스키마(subschema)** : 데이터베이스는 여러 가지 서로 다른 뷰를 기술하는 뷰 단계의 스키마를 여러 개 가질 수 있다.

<br/>

#### **물리적 데이터 독립성(physical data independence)**

물리적 스키마는 논리적 스키마 아래에 감추어져 있으나, 대게 상위의 응용 프로그램에 영향을 주지 않고서도 이를 쉽게 변경할 수 있다.

응용 프로그램이 물리적 스키마에 의존하지 않아서 물리적 스키마가 변경되어도 고칠 필요가 없다.

<br/>

## 1.4 데이터베이스 언어

데이터베이스 시스템은 다음을 제공한다.

> DDL과 DML의 경계는 명확히 구분되어 있지 않음

- 데이터베이스 스키마를 기술하는 **데이터 정의 언어(DDL, data definition language)**

- 데이터베이스 질의 및 갱신을 표현하는 **데이터 조작 언어(DML, data manipulation language)**

<br/>

### 1.4.1 데이터 정의 언어(DDL, data definition language)

#### **데이터 정의 언어(DDL)**

- 데이터 정의 언어(DDL)라는 특수한 언어로 표현된 정의들의 집합(테이블,열,데이터 타입, 인덱스, 제약조건 등을 정의한 것)을 이용해 데이터베이스 스키마를 구체화한다. 
- 데이터의 추가적인 특성을 표현하는 데도 사용된다.
- DBS에 의해 사용되는 저장 구조와 접근 방법은 **데이터 저장 및 정의 언어(data storage and definition language)**라고 하는 특별한 형태의 DDL구문을 활용해 정의할 수 있다.
- DDL 구문은 보통 사용자에게는 보이지 않는 데이터베이스 스키마 구현상의 세부사항(스키마를 실제로 어떻게 만들고 관리하는지에 관한 기술적이고 내부적인 측면)을 정의한다.
- 데이터베이스에 저장된 데이터는 해당 데이터베이스가 요구하는 일관성 제약 조건을 만족해야 한다.
  - DDL로 데이터베이스가 요구하는 일관성 제약조건을 기술할 수 있다.
    - DBS는 DB가 갱신될 때마다 이러한 제약 조건을 검토한다.

일반적으로 제약 조건은 데이터베이스와 관련된 규칙이다. 그러나 이러한 규칙을 검증하는 데는 처리 비용이 많이 든다. 

그래서 데이터베이스 시스템은 최소한의 비용으로 검증 가능한 **무결성 제약 조건**을 이행한다.

- **도메인 제약 조건(Domain Constraints)**

  - 모든 속성은 가능한 값의 도메인(예 : 정수형, 문자형, 날짜/시간형)이 지정되어 있어야 한다.
  - 속성을 선언하는 데 각각의 도메인은 값에 대한 제약 조건으로 작용한다.
  - 가장 기본적인 형태의 무결성 제약 조건으로, 새로운 데이터 항목이 DB에 입력될 때 시스템에 의해 쉽게 검증된다.

- **참조 무결성(Referential Integrity)**

  - 어떤 속성들의 집합에 대해 릴레이션의 한 값이 다른 릴레이션의 해당 속성 집합의 값으로 반드시 나타나야 하는 경우가 있다.
    - 예 : 각 수업에 열거된 학과가 실제로 존재해야 하는 상황
    - course(수업) 레코드의 dept_name(학과 이름) 값은 department 릴레이션의 일부 레코드의 dept_name 속성에 나타나야만 한다.
  -  DB의 수정이 참조 무결성을 위반하는 경우, 기본적인 절차는 위반을 유발한 동작을 거부한다.

- **권한(Authorization)**  

  - DB의 다양한 데이터에 대해서 user마다 접근을 다르게 하고 싶을 때 이러한 차별을 일반적으로 **권한**이라고 표현한다.

  - 다음 아래와 같은 유형의 권한을 사용자에게 전부 허용하거나, 혹은 전혀 할당하지 않거나, 조합해서 일부만 할당할 수 있다.

    - 읽기 권한(read authorization) : 읽기는 허용하지만 데이터 수정 허용 x
    - 삽입 권한(insert authorization) : 새로운 데이터의 삽입은 허용하지만 존재하지 않은 데이터의 수정 허용 x
    - 갱신 권한(update authorization) : 수정은 허용하지만 데이터의 삭제 허용 x
    - 삭제 권한(delete authorization) : 데이터의 삭제를 허용한다.

    

DDL은 명령문(staments)을 입력으로 받아 결과를 생성한다.

DDL의 결과는 metadata를 수록하는 데이터 사전에 저장된다.

<br/>

**메타 데이터(metadata)**

- 데이터에 대한 데이터
- 즉, 다른 데이터를 설명하고 정리하는 데 사용되는 추가적인 정보로 데이터를 쉽게 검색, 관리, 이해할 수 있도록 도와준다.
- ex) 파일 메타데이터 : 파일 이름, 크기, 생성일 등등

<br/>

**데이터 사전(Data dictionary)** 

- 특별한 형태의 테이블로서 오직 DB 시스템(일반 사용자가 아닌)에 의해서만 접근되고 갱신될 수 있다.
- DB 시스템이 실제 데이터를 읽거나 갱신 때에는 데이터 사전을 참조하여 작업을 수행

<br/>

### 1.4.2 SQL 데이터 정의 언어

SQL은 데이터 타입과 무결성 제약 조건을 갖는 테이블을 정의할 수 있도로 풍부한 DDL을 제공한다.

department 테이블을 정의하는 SQL DDL 구문

```sql
create table department
(
    department char(20),
    building   char(15),
    budget     numeric(12, 2)
);
```

SQL DDL은 다수의 무결성 제약 조건을 제공한다.

- dept_name 속성값을 primary key(주 키)로 선언할 수 있으며 그렇게 되면 어떤 두 개의 학과도 동일한 학과 이름을 가질 수 없다.
- instructor 레코드에 출현하는 dept_name 속성은 department 테이블에 있는 레코드들의 dept_name속성으로 반드시 나와야한다.

<br/>

### 1.4.3 데이터 조작 언어

데이터 조작 언어(DML)는 사용자가 적절한 데이터 모델로 구성된 **데이터에 접근하거나 이것을 조작**할 수 있도록 하는 언어

<br/>

#### 접근 형태

- DB 내에 저장된 정보를 검색(retrieve)
- DB에 새로운 정보를 삽입(insert)
- DB로부터 정보를 삭제(delete)
- DB 내에 저장된 데이터를 수정(update)

<br/>

#### 두 가지 형태의 DML

- **절차적(procedural) DML** 

  - 어떤 데이터가 필요하며(what) 그 데이터를 어떻게 구할지(how) 지정할 것을 요구

  > 어떻게 구할지라는 것은 데이터를 가져오는 구제적인 절차나 방법을 말하는데 예를 들어 인덱스 사용, 테이블 스캔등을 말함

- **선언적(declarative) 또는 비절차적(non procedure) DML** 

  - 필요한 데이터를 어떻게 구할지 명시할 필요 없이, **어떠한 데이터가 필요한지 지정할 것만 사용자에게 요구**
  - 보통 절차적 DML보다 배우기 쉽고 사용하기도 쉬움
  - 사용자가 데이터를 어떻게 구할지를 구체적을 명시하지 않아서 DB 시스템 스스로 데이터에 효울적으로 접근하는 법을 찾아야 한다.

> **질의(query)** : 정보 검색을 요청하는 구문
>
> **질의어(query language)** : DML에서 정보 검색을 담당하는 부분

<br/>

### 1.4.4 SQL 데이터 조작 언어

SQL 질의어는 비절차적(선언적) 언어이다. 

입력으로 몇 개의 테이블(한 개도 가능)을 받아 항상 한 개의 테이블을 반환한다.

<br/>

예제1) 역사학과의 모든 교수의 이름을 찾는 SQL 질의어

```sql
select instructor.name 
from instructor
where instructor.dept_name = 'History';
```

<br/>

예제2) 예산이 $95,000보다 많은 학과의 모든 교수의 ID와 학과 이름을 찾는 SQL 질의어

```sql
select instructor.ID, department.dept_name
from instructor,department
where instrctor.dept_name = department.dept_name and department.budget > 95000;
# 교수 테이블과 학과 테이블을 dept_name 필드를 기준으로 조인합니다. 
# 즉, 교수와 학과가 동일한 학과 이름을 가질 때만 결과에 포함됩니다.
```

<br/>

### 1.4.5 응용 프로그램에서 데이터베이스 접근

SQL은 사용자 입력을 처리하거나, 화면에 데이터를 출력하거나, 네트워크 통신을 제어하는 등의 복잡한 작업을 수행할 수 없다.

이러한 계산과 동작은 DB에 있는 데이터에 접근할 수 있는 내장형 SQL과 호스트 언어(host language(c,c++,java))로 작성된다.

<br/>

**응용 프로그램(application program)** : DB와 상호작용하는데 이용되는 프로그램

DB에 접근하기 위해, 호스트 언어에 있는 DML 구문이 실행될 DB로 보내져야 한다.

이것은 DML 구문을 DB에 보내고 결과를 검색하는 데 사용되는 응용 프로그램 인터페이스를 활용하여 이루어진다.

<br/>

**ODBC(Open Database Connectivity) 표준**

- C와 다른 몇개의 언어를 위한 응용 프로그램 인터페이스를 정의한다.

<br/>

**JDBC(Java Database Connectivity) 표준**

- Java 언어를 위한 해당 인터페이스를 정의한다.

<br/>

## 1.5 데이터베이스 설계

#### DB설계의 여러 단계

**1. 초기 단계**

- 장래의 DB 사용자들이 필요로 하는 데이터를 충분히 규정하는 것이다.

- 이 단계의 결과물은 **사용자의 요구 명세서(specification of user requirements)**이다.

<br/>

**2. 개념적 설계(conceptual-design) 단계**

- 설계자는 **데이터 모델을 선택하고**, 이를 사용하여 **사용자의 요구를 DB의 개념적 스키마로 바꾼다.(E-R diagram)**
- 이 단계에서 개발된 스키마는 기업의 상세한 개관을 제공한다.(DB가 다루게될 데이터와 그 관계에 대한 포괄적이고 종합적인 시각 제공)
- 이 단계에서 설계자의 초점은 **물리적 저장 방법보다 데이터와 그들의 관계를 기술하는 데 맞추어져 있다.**
- 관계형 모델에서 개념적 설계 단계는 DB에서 우리가 포착하길 원하는 **어떤 속성**과, 다양한 테이블을 구성하는 **이러한 속성을 어떻게 그룹화할 것인가**에 대한 결정과 관련된다. 
  - 결정 두가지 방법 
    - **개체-관계모델 사용**, 
    - 모든 속성의 집합을 입력으로 받아 테이블의 집합을 생성하는 **정규화**로 알려진 알고리즘 사용 
- 사용자는 **기능적 요구 사항 명세서(specification of functional requirement)**에 데이터에 적용될 연산(혹은 트랜잭션)의 종류를 기술한다. 
  - 데이터의 변경 or 갱신, 특정 데이터의 검색 및 추출, 데이터 삭제

<br/>


> 추상 데이터 모델로부터 DB 구현으로 이동하는 과정은 마지막 두 설계 단계에서 이루어짐

**3. 논리 설계 단계(logical-design phase)**

- 설계자는 상위의 개념적 스키마를 사용할 DB의 구현 데이터 모델에 대응시킨다.(논리적 스키마, relation 스키마)

<br/>

**4. 물리 설계 단계(physical-design phase)**

- 설계자는 논리적 설계 단계의 결과로 나온 시스템 특유의 DB 스키마를 이 단계에서 이용

- DB의 물리적 속성이 구체화되는 단계
  - 이러한 속성은 파일 구성(file organization)의 형식과 내부적인 저장 구조를 포함한다.

<br/>

## 1.6 데이터베이스 엔진

DB 시스템은 여러 모듈로 구성되며, 각 모듈은 DB의 여러 책무를 나누어 맡는다.

<br/>

#### 기능적인 관점에서의 DB 시스템

1. **저장 장치 관리자(storage mananger)**
2. **질의 처리기(query processor)**

<br/>

**트랜잭션 관리자(transaction manager)**

- 응용 개발자로 하여금 일련의 **DB 접근을 완전하게 수행하거나 혹은 전혀 실행되지 않은 것처럼 하나의 단위로 처리**할 수 있도록 만들어준다.
  - 데이터에 대한 동시 접근, 시스템 고장에 대한 세부적인 사항을 신경 쓰지 않아도됨

<br/>

DB 엔진은 **전통적으로 중앙화된 컴퓨터 시스템이**였으나 **오늘날에는 병렬화 처리**가 대규모 데이터를 효과적으로 처리하는데 중요

<br/>

### 1.6.1 저장 장치 관리자(storage manager)

#### 저장 장치 관리자(storage manager) 

- **DB 하부에 저장된 데이터와 응용 프로그램 및 질의 사이의 인터페이스를 제공**하는 DB시스템 요소이다.

- 디스크로 I/O는  CPU 속도에 비해 매우 느리기에, DB시스템은 **디스크와 메인 메모리 사이의 데이터 이동이 최소화되도록 데이터를 구조화**한다.

- **파일 관리자(file manager)와 상호작용**하는 책무가 있다.
- 다양한 **DML 구문을 하위 단계의 파일 시스템 명령으로 변환**한다.
  - 그러므로 저장 장치관리자는 **DB 내의 데이터를 저장하고 검색하며, 갱신하는 책임**이 있다.

<br/>

#### 저장 장치 관리자의 구성요소

- **권한과 무결성 관리자(authorization and integrity manager)**
  - 데이터에 접근하는 사용자의 권한을 확인
  - 무결성 제약 조건을 만족하는지  검사
- **트랜잭션 관리자(transaction manager)**
  - 시스템에 고장이 발생해도 DB가 일관성 있는 정확한 상태를 유지하도록 보장
  - 동시에 실행되는 트랜잭션들이 충돌 없이 잘 이루어지도록 보장
- **파일 관리자(file manager)**
  - 디스크 공간의 할당과 디스크상에 저장된 정보 표현을 위해 자료구조를 관리한다.
- **버퍼 관리자(buffer manager)**
  - 디스크로부터 메인 메모리로 데이터를 인출하는 과정, 메인 메모리에서 캐시로 보낼 데이터를 결정하는 책임이 있다.
- **데이터 파일**
  - DB 자체를 저장한다.
- **데이터 사전(data dictionary)**
  - DB의 구조에 관한 메타데이터를 저장한다. 특히 DB의 스키마를 여기에 저장.
- **인덱스**
  - 특정한 값을 가지고 있는 데이터 항목에 빠르게 접근하기 위한 것
  - DB 인덱스는 특정한 값을 가지는 데이터 항목을 지정하는 포인터를 제공

<br/>

### 1.6.2 질의 처리기(query processor)

- DB시스템이 데이터에 **접근하는 과정을 단순화하고 효율적으로 만드는 역할**을 한다.

- 뷰 단계에서 DB 사용자는 DB의 복잡한 물리적 단계의 구현을 몰라도, 질의 처리기를 통해 데이터를 간단하게 조회하고 작업할 수 있다.

  - 사용자가 데이터를 쉽게 접근할 수 있도록 **중간에서 복잡한 작업을 대신 처리**합니다.

- 논리적 단계에서 비절차적 언어(DML)로 작성된 **갱신 요구와 질의를 물리적 단계의 효율적인 일련의 연산으로 변환**한다.

  > 물리적 단계 효율적인 일련의 연산이란 : 사용자가 요청한 데이터를 실제로 데이터베이스 내부에서 처리하고 검색하는 데 필요한 구체적인 작업

<br/>

#### 질의처리기의 구성요소

- **DDL 인터프리터**

  - DDL 문을 해독하여 데이터 사전 내에 기록한다.

- **DML 컴파일러**

  > 질의 평가 계획 : 질의 처리를 위한 일련의 기본 연산

  - 질의어 내의 DML 문을 질의 평가 엔진이 이해할 수 있는 하위 단계 명령어로 구성된 질의 평가 계획으로 바꾼다.

  - 질의는 보통 동일한 결과를 반환하는 여러 가지 질의 평가 계획으로 변환될 수 있다.

  - 여러 질의 평가 계획 중 가장 낮은 비용의 계획을 선택해주는 **질의 최적화(query optimization)**을 수행한다.
  
- **질의 평가 엔진(query evaluation engine)**

  - DML 컴파일러가 생성한 하위 단계 명령을 실행한다.
  - 질의 평가 계획을 받아들이고 그 계획을 수행한 후, 질의에 대한 결과를 넘겨준다.

<br/>

### 1.6.3 트랜잭션 관리

#### 트랜잭션(transaction)

DB 응용 프로그램에서 **하나의 논리적 기능을 수행하는 연산의 모임**

각 트랜잭션은 4가지 특성을 모두 지닌 단위로 수행되어야한다.

각각의 트랜잭션이 DB의 일관성을 유지하도록 여러 트랜잭션을 적절하게 정의해야함

<br/>

#### 트랜잭션의 성질(ACID)

#### 원자성(Atomicity)

트랜잭션의 모든 연산들이 정상적으로 수행되거나, 아니면 어떠한 연산도 수행되지 않아야 한다.

-  **all or none 요구 조건**

<br/>

#### 일관성(Consistency)

고립 상태(동시에 수행되는 트랜잭션이 없는 상태)에서 트랜잭션 수행이 **DB의 일관성을 보존**해야한다.

> 일관성 :  데이터베이스를 구성할 때에 정해놓은 규칙들

즉, 트랜잭션이 실행되기 전과 후에 DB가 일관된 상태를 유지해야한다.

<br/>

#### 고립성(Isolation)

여러 트랜잭션이 동시에 수행되더라도 각각의 트랜잭션은 **다른 트랜잭션의 수행에 영향을 받지 않고** **독립적으로 수행**되어야 한다

- 여러 트랜잭션이 동시에 실행되더라도 데이터의 일관성을 보장

<br/>

#### 지속성(Durability)

트랜잭션이 성공적으로 수행되었다면, 트랜잭션에 의해 변경된 DB의 내용은 시스템 오류가 발생하더라도 **영구적으로 반영**되어야 한다.

<br/>

#### 트랜잭션 관리자(transaction manager)

트랜잭션 관리자는 동시성 제어 관리자와 복구 관리자로 구성된다.  

- **동시성 제어 관리자(concurrency-control manager)**
  - DB의 일관성을 보장하기 위해 **동시에 실행되는 트랜잭션들 간의 상호작용을 제어**하는 책임을 지님

- **복구 관리자(failure recovery)**
  - 원자성과 지속성을 보장한다.(DB 시스템, 특히 복구관리자의 책임이다.)
  - 원자성의 특성을 보장하려면 실패한 트랜잭션이 DB의 상태에 아무런 영향을 주지 말아야 한다.
  - 따라서 DB는 트랜잭션이 일어나기 전 상태로 재저장되어야하므로 **고장 복구(failure recovery)**를 수행해야만 한다.
  - 시스템의 고장을 탐지하고 고장 발생 이전 상태로 DB를 재저장하는 것은 DB 시스템의 책임

<br/>

## 1.7 데이터베이스 및 응용 구조

아래 그림은 중앙화된 서버상에서 돌아가는 DB 시스템의 구조를 보여준다.

![그림 1 3 시스템 구조](https://github.com/user-attachments/assets/62e32299-c4d8-488e-8211-a4b613159ad6)

#### 병렬 DB vs 분산 DB

| 구분              | 병렬 데이터베이스 (Parallel DB)                              | 분산 데이터베이스 (Distributed DB)                       |
| ----------------- | ------------------------------------------------------------ | -------------------------------------------------------- |
| **구조**          | 여러 프로세서가 **공유 메모리**와 디스크로 **하나의 DB를 처리** | **여러 물리적 위치**의 노드에 데이터를 **분산하여 처리** |
| **데이터 저장**   | **하나의 저장소**에서 병렬 처리                              | 데이터를 **분할** 또는 **복제**하여 여러 노드에 저장     |
| **트랜잭션 관리** | 단일 인스턴스에서 병렬 처리, 비교적 간단                     | 노드 간 통신 필요, **분산 트랜잭션** 관리 복잡           |
| **확장성**        | **수직 확장** (더 많은 CPU 추가)                             | **수평 확장** (노드 추가로 확장)                         |

<br/>

#### 중앙 집중형 DB vs 분산 DB

|      | 중앙 집중형 DB                                               | 분산 DB                                                      |
| ---- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 장점 | 1. 구축과 관리가 간단하다.<br />2. 데이터 일관성을 유지하기 쉽다. | 1. 병렬처리를 수행하기 때문에 대규모 데이터를 효과적으로 처리<br />2. 데이터베이스 **신뢰성과 가용성**이 높다.(한 서버가 다운되더라도 다른 서버에서 데이터 제공가능)<br />3. 분산 데이터베이스를 추가하여 **시스템 용량 확장**이 쉽다. |
| 단점 | 1. 중앙 서버에 장애가 발생하면 시스템 전체가 마비된다.<br />2. 분산DB보다 처리속도가 느리다. | 1. 데이터 무결성 관리 어렵다<br />2. 보안 관리 어렵다<br />3. 데이터베이스 설계가 복잡하다<br />4. 데이터베이스가 여러 네트워크를 통해서 분리되어 있기 때문에 관리, 통제가 어렵다. |

<br/>

#### 계층 구조

back-end로 DB를 사용하는 응용의 구조는 두 부분 또는 세부분으로 나뉜다.

![그림 1 4 2계층 및 3계층 구조](https://github.com/user-attachments/assets/1993acfa-3451-40a2-afe6-c9ef68597a0c)

**2계층 구조**

- 초기 데이터베이스 응용
- 클라이언트와 데이터베이스 사이에 바로 통신하는 방식
- 응용프로그램이 클라이언트 상에 존재하고 특정 질의문을 보냄으로써 서버에 있는 데이터베이스 시스템의 기능(데이터 조회, 삽입, 수정, 삭제 등)을 불러온다.

<br/>

**3계층 구조**

- 클라이언트는 어떤 데이베이스 호출도 직접적으로 수행하지 않고 단지 전처리 시스템으로서의 역할만 한다.

> 전처리 시스템 역할 : 단순히 사용자 입력을 받아 이를 검증하고, 응용 서버에 전달하는 역할만 수행한
>
> ​				    데이터를 직접 처리하거나 저장하는 책임을 지지 않음

- 프론트엔드(클라이언트)는 응용 서버(application server)와 통신을 한다.
- 응용 서버는 차례로 데이터에 접근하기 위해 데이터베이스 시스템과 통신한다.

- 어떤 작업(action)이 어떠한 조건하에서 수행되는지를 의미하는 **비즈니스 로직(business logic)은 응용 서버 쪽에 포함**되어 있다.

- 2계층 응용보다 더 좋은 성능뿐만 아니라 더 나은 보안을 제공한다.

<br/>

## 1.8 데이터베이스 사용자와 관리자

### 1.8.2 데이터베이스 관리자

DBMS을 도입하는 중요한 이유중 하나는 **데이터에 접근하는 프로그램 모두에  대해서 중앙 제어를 가하자는 것**이다.

중앙에서 제어하는 사람을 데이터베이스 관리자(database adminstrator, DBA)라고 한다.

데이터베이스 관리자는 다음과 같은 일을 한다.

- 스키마 정의
- 저장 구조와 접근 방법 정의
- 스키마 및 물리 구조 수정
- 데이터 접근 권한 인정
- 일상적인 유지보수
